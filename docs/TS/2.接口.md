# 接口

1. 基础

类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以

```ts
interface IPerson {
  name: string;
  age: number;
}
function say(person: IPerson): void {
  console.log(`my name is ${person.name}, and age is ${person.age}`);
}
let me = {
  name: "funlee",
  age: 18
};
say(me); // my name is funlee, and age is 18
```

2. 可选属性

定义可选属性的接口，只需在可选属性名字的定义后面加一个 ? 符号

```ts
interface IPerson {
  name: string;
  age: number;
  love?: string;
}
```

3. 只读属性

定义只读属性的接口，只需在只读属性名前加 readonly

```ts
interface IPerson {
  readonly name: string;
  age: number;
  love?: string;
}
let me: IPerson = {
  name: "funlee",
  age: 18
};
me.name = "new name"; // error!
```

4. 函数类型

接口可以描述函数类型，它定义了函数的参数列表和返回值类型，参数列表里的每个参数都需要名字和类型，函数的参数名不需要与接口里定义的名字相匹配，只需要类型兼容就可以了。

```ts
let getArea: (width: number, height: number) => number = (
  w: number,
  h: number
): number => {
  return w * h;
};
console.log(getArea(5, 6)); // 30
```

5. 继承接口

和类一样，接口也可以相互继承，如：

```ts
interface Shape {
  color: string;
}
interface Square extends Shape {
  sideLength: number;
}
let square: Square = {
  color: "blue",
  sideLength: 18
};
```

同时，一个接口也可以继承多个接口，创建出多个接口的合成接口，如：

```ts
interface Shape {
  color: string;
}
interface PenStroke {
  penWidth: number;
}
interface Square extends Shape, PenStroke {
  sideLength;
}
const square = <Square>{};
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
```

6. 混合类型(这个是真没看懂)

允许让一个对象同时作为函数和对象使用，并带有额外的属性，如：

```ts
interface MixedDemo {
  (str: string): void;
  defaultStr: string;
}

function foo(): MixedDemo {
  let x = <MixedDemo>function(str: string) {
    console.log(str);
  };
  x.defaultStr = "Hello, world";
  return x;
}

let c = foo();
c("This is a function"); // 'This is a function'
console.log(c.defaultStr); // 'Hello, world'
```

7. 接口继承类

接口可以继承自一个类，从而像声明了所有类中存在的成员，并且 private 和 protected 成员也会被继承，这意味着：只有类自己或子类能够实现该接口，例子如：

```ts
class A {
  protected propA: string;
}
interface I extends A {
  method(): void;
}
```
