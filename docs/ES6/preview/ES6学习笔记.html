<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:ES6学习笔记</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 align="center">ES6学习笔记</h1>

<h2 id="let-const-">let 和 const 命令</h2>
<p><strong>let</strong>：块级作用域、不存在变量提升、暂时性死区、不允许重复声明。</p>
<p><strong>const</strong>：定义必须赋值、不可更改。</p>
<h2 id="-">解构</h2>
<h3 id="-">数组解构</h3>
<ol>
<li>基础用法</li>
</ol>
<pre><code>// 例一
let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

// 例二
let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre><h3 id="-">对象解构</h3>
<ol>
<li>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量</li>
</ol>
<pre><code>// 例一
let { log, sin, cos } = Math;

// 例二
const { log } = console;
log(&#39;hello&#39;) // hello
</code></pre><ol start="2">
<li>如果变量名与属性名不一致，必须写成下面这样</li>
</ol>
<pre><code>let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // &quot;aaa&quot;

let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };
let { first: f, last: l } = obj;
f // &#39;hello&#39;
l // &#39;world&#39;
</code></pre><ol start="3">
<li>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</li>
</ol>
<pre><code>let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre><ol start="4">
<li>注意，这时 p 是模式，不是变量，因此不会被赋值。如果 p 也要作为变量赋值，可以写成下面这样。</li>
</ol>
<pre><code>let obj = {
  p: [
    &#39;Hello&#39;,
    { y: &#39;World&#39; }
  ]
};

let { p, p: [x, { y }] } = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
p // [&quot;Hello&quot;, {y: &quot;World&quot;}]
</code></pre><ol start="5">
<li>下面是嵌套赋值的例子</li>
</ol>
<pre><code>let obj = {};
let arr = [];

({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

obj // {prop:123}
arr // [true]
</code></pre><h3 id="-">默认值</h3>
<ol>
<li>默认值生效的条件是，对象的属性值严格等于 undefined</li>
</ol>
<pre><code>var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
</code></pre><h3 id="-">注意点</h3>
<ol>
<li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构</li>
</ol>
<pre><code>let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
</code></pre><h3 id="-">字符串解构</h3>
<ol>
<li>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</li>
</ol>
<pre><code>const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;
</code></pre><ol start="2">
<li>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值</li>
</ol>
<pre><code>let {length : len} = &#39;hello&#39;;
len // 5
</code></pre><h3 id="-">函数参数解构</h3>
<ol>
<li>函数参数的解构也可以使用默认值。</li>
</ol>
<pre><code>function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</code></pre><ol start="2">
<li>下面的写法会得到不一样的结果。</li>
</ol>
<pre><code>function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
</code></pre><p>上面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果。</p>
<h3 id="-">用途</h3>
<ol>
<li>交换变量的值</li>
</ol>
<pre><code>let x = 1;
let y = 2;

[x, y] = [y, x];
</code></pre><ol start="2">
<li>从函数返回多个值</li>
</ol>
<blockquote>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
</blockquote>
<pre><code>// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
</code></pre><h2 id="-">字符串</h2>
<ol>
<li>字符串遍历</li>
</ol>
<pre><code>for (let codePoint of &#39;foo&#39;) {
  console.log(codePoint)
}
// &quot;f&quot;
// &quot;o&quot;
// &quot;o&quot;
</code></pre><ol start="2">
<li>模板字符串之中还能调用函数</li>
</ol>
<pre><code>function fn() {
  return &quot;Hello World&quot;;
}

`foo ${fn()} bar`
// foo Hello World bar
</code></pre><ol start="3">
<li>模板字符串甚至还能嵌套</li>
</ol>
<pre><code>const tmpl = addrs =&gt; `
  &lt;table&gt;
  ${addrs.map(addr =&gt; `
    &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;
  `).join(&#39;&#39;)}
  &lt;/table&gt;
`;
</code></pre><h2 id="-">字符串方法</h2>
<ol>
<li>includes()、startsWith()、endsWith()</li>
</ol>
<p>includes()：返回布尔值，表示是否找到了参数字符串。</p>
<p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
<p>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
<pre><code>let s = &#39;Hello world!&#39;;

s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true
</code></pre><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<pre><code>let s = &#39;Hello world!&#39;;

s.startsWith(&#39;world&#39;, 6) // true
s.endsWith(&#39;Hello&#39;, 5) // true
s.includes(&#39;Hello&#39;, 6) // false
</code></pre><ol start="2">
<li>repeat()</li>
</ol>
<p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次。</p>
<pre><code>&#39;x&#39;.repeat(3) // &quot;xxx&quot;
&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;
</code></pre><ol start="3">
<li>padStart()、padEnd()</li>
</ol>
<p>如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全</p>
<pre><code>&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;

&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
</code></pre><ol start="4">
<li>trimStart()、trimEnd()</li>
</ol>
<p>它们的行为与 trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p>
<pre><code>const s = &#39; abc &#39;;

s.trim() // &quot;abc&quot;
s.trimStart() // &quot;abc &quot;
s.trimEnd() // &quot; abc&quot;
</code></pre><ol start="5">
<li>matchAll()</li>
</ol>
<p>matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p>
<h2 id="class">class</h2>
<ol>
<li>由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。Object.assign 方法可以很方便地一次向类添加多个方法。</li>
</ol>
<pre><code>class Point {
  constructor(){
    // ...
  }
}

Object.assign(Point.prototype, {
  toString(){},
  toValue(){}
});
</code></pre><ol start="2">
<li>与 ES5 一样，在“类”的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</li>
</ol>
<pre><code>class MyClass {
  constructor() {
    // ...
  }
  get prop() {
    return &#39;getter&#39;;
  }
  set prop(value) {
    console.log(&#39;setter: &#39;+value);
  }
}

let inst = new MyClass();

inst.prop = 123;
// setter: 123

inst.prop
// &#39;getter&#39;
</code></pre><ol start="3">
<li>类的属性名，可以采用表达式。</li>
</ol>
<pre><code>let methodName = &#39;getArea&#39;;

class Square {
  constructor(length) {
    // ...
  }

  [methodName]() {
    // ...
  }
}
</code></pre><ol start="4">
<li>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</li>
</ol>
<pre><code>class Foo {
  static classMethod() {
    return &#39;hello&#39;;
  }
}

Foo.classMethod() // &#39;hello&#39;

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
</code></pre><ol start="5">
<li>注意，如果静态方法包含 this 关键字，这个 this 指的是类，而不是实例。</li>
</ol>
<pre><code>class Foo {
  static bar() {
    this.baz();
  }
  static baz() {
    console.log(&#39;hello&#39;);
  }
  baz() {
    console.log(&#39;world&#39;);
  }
}

Foo.bar() // hello
</code></pre><ol start="6">
<li>实例属性除了定义在 constructor()方法里面的 this 上面，也可以定义在类的最顶层。</li>
</ol>
<pre><code>
class foo {
  bar = &#39;hello&#39;;
  baz = &#39;world&#39;;

  constructor() {
    // ...
  }
}
</code></pre><ol start="7">
<li>静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。</li>
</ol>
<pre><code>class MyClass {
  static myStaticProp = 42;

  constructor() {
    console.log(MyClass.myStaticProp); // 42
  }
}
</code></pre><ol start="8">
<li>Class 内部调用 new.target，返回当前 Class</li>
</ol>
<pre><code>class Rectangle {
  constructor(length, width) {
    console.log(new.target === Rectangle);
    this.length = length;
    this.width = width;
  }
}

var obj = new Rectangle(3, 4); // 输出 true
</code></pre><ol start="9">
<li>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</li>
</ol>
<pre><code>class Shape {
  constructor() {
    if (new.target === Shape) {
      throw new Error(&#39;本类不能实例化&#39;);
    }
  }
}

class Rectangle extends Shape {
  constructor(length, width) {
    super();
    // ...
  }
}

var x = new Shape();  // 报错
var y = new Rectangle(3, 4);  // 正确
</code></pre><ol start="10">
<li>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。</li>
</ol>
<pre><code>class Point { /* ... */ }

class ColorPoint extends Point {
  constructor() {
  }
}

let cp = new ColorPoint(); // ReferenceError
</code></pre><ol start="11">
<li>super 作为函数调用时，代表父类的构造函数。super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li>
</ol>
<pre><code>\\函数
class A {
  constructor() {
    console.log(new.target.name);
  }
}
class B extends A {
  constructor() {
    super();
  }
}
new A() // A
new B() // B

\\ 对象
class A {
  p() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    console.log(super.p()); // 2
  }
}

let b = new B();
</code></pre>
          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>