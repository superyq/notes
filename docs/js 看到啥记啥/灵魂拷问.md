# 灵魂拷问

## 问题

1. JS原始数据类型有哪些？引用数据类型有哪些？

2. 说出下面运行的结果，解释原因。

```js
function test(person) {
  person.age = 26
  person = {
    name: 'hzj',
    age: 18
  }
  return person
}
const p1 = {
  name: 'fyq',
  age: 19
}
const p2 = test(p1)
console.log(p1) // -> ?
console.log(p2) // -> ?
```

3. null是对象吗？为什么？

4. '1'.toString()为什么可以调用？

5. 0.1+0.2为什么不等于0.3？

6. 如何理解BigInt?

## 答案

1. 7种原始数据：boolean, string, number, null, undefined, symbol, bigint
   引用数据：对象Object（普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）

2. p1：{ name: 'fyp', age: 26 }
   p2：{ name: 'hzj', age: 18 }

   在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2

3. null不是对象：虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以    将它错误的判断为 object 。

4. 其实在这个语句运行的过程中做了这样几件事情：
   ```js
    var s = new Object('1');
    s.toString();
    s = null;
   ```
   第一步: 创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。

   第二步: 调用实例方法。

   第三步: 执行完方法立即销毁这个实例。

   整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。
  
5. 0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。

6. BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。
   
   这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。
   
   要创建BigInt，只需要在数字末尾追加n即可。

   另一种创建BigInt的方法是用BigInt()构造函数、

## 问题

1. typeof 是否能正确判断类型？

2. instanceof能否判断基本数据类型？

3. 能不能手动实现一下instanceof的功能？

4. Object.is和===的区别？

## 答案

1. 