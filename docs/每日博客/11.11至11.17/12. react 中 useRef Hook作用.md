# react 中 useRef Hook 作用

`useRef`是一个非常实用的钩子函数

### 一、访问和操作 DOM 元素

- **获取 DOM 元素引用**
  - **基本原理**：在 React 组件中，我们常常需要直接操作 DOM 元素，比如获取输入框的焦点、测量元素的尺寸、操作视频或音频元素等。`useRef`提供了一种方式来获取对这些 DOM 元素的引用。通过创建一个`ref`对象，并将其绑定到 React 元素上，就可以在组件的任何地方访问和操作对应的 DOM 元素。
  - **代码示例**：

```javascript
import React, { useRef, useEffect } from "react";

const InputFocusComponent = () => {
  const inputRef = useRef(null);

  useEffect(() => {
    // 组件挂载后，使输入框获得焦点
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, []);

  return (
    <div>
      <input type="text" ref={inputRef} />
    </div>
  );
};

export default InputFocusComponent;
```

    - 在这个例子中，首先使用`useRef`创建了一个`ref`对象`inputRef`，然后将这个`ref`对象通过`ref`属性绑定到`<input>`元素上。在`useEffect`中，当组件挂载后（依赖项数组为空，表示只在挂载时执行），通过`inputRef.current`访问到输入框DOM元素，并调用`focus`方法使输入框获得焦点。

- **跨渲染周期保持引用**
  - **渲染周期中的稳定性**：React 组件在每次重新渲染时，函数内部的局部变量都会重新创建，但`useRef`创建的引用在整个组件的生命周期内是保持不变的。这使得它在处理需要在多次渲染之间保持状态或引用的情况时非常有用。例如，在一个定时器的场景中，需要在组件挂载时启动定时器，并在组件卸载时清除定时器，`useRef`可以帮助我们保持对定时器 ID 的引用。
  - **代码示例**：

```javascript
import React, { useRef, useEffect, useState } from "react";

const TimerComponent = () => {
  const timerRef = useRef(null);
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 组件挂载时启动定时器
    timerRef.current = setInterval(() => {
      setCount((prevCount) => prevCount + 1);
    }, 1000);

    return () => {
      // 组件卸载时清除定时器
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  return (
    <div>
      <p>Seconds passed: {count}</p>
    </div>
  );
};

export default TimerComponent;
```

    - 在这个例子中，`timerRef`在整个组件的生命周期内保持不变。在`useEffect`中，当组件挂载时，定时器的ID被存储在`timerRef.current`中，即使组件多次重新渲染，这个引用也不会改变。当组件卸载时，通过`timerRef.current`可以准确地清除定时器。

### 二、保存可变值

- **避免重新渲染触发的问题**
  - **与 state 的区别**：在 React 中，`state`的更新会触发组件的重新渲染，但有时候我们需要在组件内部保存一个可变的值，而不希望每次这个值变化时都引起组件重新渲染。`useRef`创建的值就可以满足这种需求。例如，在一个数据获取的场景中，我们可能需要记录数据是否正在被获取，这个状态不需要触发组件重新渲染。
  - **代码示例**：

```javascript
import React, { useRef, useState, useEffect } from "react";

const DataFetchingComponent = () => {
  const isFetchingRef = useRef(false);
  const [data, setData] = useState(null);

  useEffect(() => {
    if (!isFetchingRef.current) {
      isFetchingRef.current = true;
      fetch("https://example.com/api/data")
        .then((response) => response.json())
        .then((jsonData) => {
          setData(jsonData);
          isFetchingRef.current = false;
        });
    }
  }, []);

  return (
    <div>
      {data ? (
        <pre>{JSON.stringify(data)}</pre>
      ) : (
        <p>
          {isFetchingRef.current ? "Fetching data..." : "No data available"}
        </p>
      )}
    </div>
  );
};

export default DataFetchingComponent;
```

    - 在这个例子中，`isFetchingRef`用于记录数据是否正在被获取。当开始获取数据时，`isFetchingRef.current`被设置为`true`，这个操作不会触发组件重新渲染。只有当`state`中的`data`发生变化时，组件才会重新渲染，这样就避免了不必要的渲染。

- **在复杂逻辑中的应用**
  - **多个异步操作或副作用协调**：在处理多个异步操作或复杂的副作用时，`useRef`可以帮助我们管理一些中间状态或协调操作的顺序。例如，在一个表单提交的场景中，可能需要在提交过程中禁用表单、显示加载指示器，并在提交成功或失败后恢复表单状态。`useRef`可以用来保存表单是否被禁用的状态、加载指示器的显示状态等。
  - **代码示例**：

```javascript
import React, { useRef, useState } from "react";

const FormSubmitComponent = () => {
  const isSubmittingRef = useRef(false);
  const [formData, setFormData] = useState({});
  const [submissionStatus, setSubmissionStatus] = useState("");

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!isSubmittingRef.current) {
      isSubmittingRef.current = true;
      try {
        // 模拟表单数据提交
        await new Promise((resolve) => setTimeout(resolve, 2000));
        setSubmissionStatus("Success");
      } catch (error) {
        setSubmissionStatus("Failure");
      } finally {
        isSubmittingRef.current = false;
      }
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* 表单字段 */}
      <input
        type="text"
        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
      />
      <button type="submit" disabled={isSubmittingRef.current}>
        Submit
      </button>
      {submissionStatus && <p>{submissionStatus}</p>}
    </form>
  );
};

export default FormSubmitComponent;
```

    - 在这个例子中，`isSubmittingRef`用于记录表单是否正在提交。在提交过程中，通过这个引用可以禁用表单按钮，避免多次提交。这个值的变化不会触发组件重新渲染，保证了表单操作的流畅性。
