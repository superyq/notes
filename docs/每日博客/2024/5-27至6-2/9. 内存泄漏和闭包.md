# 闭包与内存泄漏、垃圾回收

1. 闭包

函数嵌套函数，内部函数可以引用外部函数的参数和变量。参数和变量不会被垃圾回收机制收回

2. 垃圾回收机制

什么是垃圾？就是不再需要的内存。什么是垃圾回收机制？就是浏览器会自动回收掉我们不要的数据。那浏览器怎么判断什么是我们不要的数据？就是我们无法触达的数据，也就是访问不到的数据。

3. 内存泄漏

有些数据是我们不要的，但是还能被访问，被触达。浏览器的垃圾回收机制无法将这些数据回收，这就是内存泄漏。

那怎么处理内存泄漏？我们需要让这些内存不可触达，垃圾回收机制就会把它回收掉，怎么让它不可触达呢，设置为 null，之前的数据就无法触达了，就能被回收掉。

4. 闭包导致的内存泄漏

在闭包中持有了不再需要的函数引用，会导致函数关联的词法环境无法销毁，从而导致内存泄漏。如下：dfn 函数在我们调用一次后，其实不在需要了，但是我们没有将它设置为 null，那么它所关联的 arr 变量，还可以被访问到，浏览器的垃圾回收机制就不会回收它，就会导致内存泄漏。

```js
function fn() {
  const arr = [1, 2, 3, 4];
  function _fn() {
    console.log(arr);
  }
  return _fn;
}
const dfn = fn();
dfn();
```

当多个函数共享词法环境时，会导致词法环境膨胀，从而导致出现无法触达也无法回收的内存空间。从而导致内存泄漏。如下：\_fn 函数没用到 arr 数据，arr 数据我们无法触达，但是在同一个词法环境中，还有一个函数用到了 arr，垃圾回收机制不敢将它回收。

```js
function fn() {
  const arr = [1, 2, 3, 4];
  function __fn() {
    console.log(arr);
  }
  function _fn() {}
  return _fn;
}
const dfn = fn();
dfn();
```

总结：永远不要提前优化，出了问题再去优化。
